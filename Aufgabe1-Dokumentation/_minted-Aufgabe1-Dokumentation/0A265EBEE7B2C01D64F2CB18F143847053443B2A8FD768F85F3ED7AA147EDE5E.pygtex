\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{The MIT License (MIT)}

\PYG{l+s+sd}{Copyright (c) 2016 Christian August Reksten\PYGZhy{}Monsen \PYGZam{} 2019 Lukas Rost}

\PYG{l+s+sd}{Permission is hereby granted, free of charge, to any person obtaining a copy}
\PYG{l+s+sd}{of this software and associated documentation files (the \PYGZdq{}Software\PYGZdq{}), to deal}
\PYG{l+s+sd}{in the Software without restriction, including without limitation the rights}
\PYG{l+s+sd}{to use, copy, modify, merge, publish, distribute, sublicense, and/or sell}
\PYG{l+s+sd}{copies of the Software, and to permit persons to whom the Software is}
\PYG{l+s+sd}{furnished to do so, subject to the following conditions:}

\PYG{l+s+sd}{The above copyright notice and this permission notice shall be included in all}
\PYG{l+s+sd}{copies or substantial portions of the Software.}

\PYG{l+s+sd}{THE SOFTWARE IS PROVIDED \PYGZdq{}AS IS\PYGZdq{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}
\PYG{l+s+sd}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}
\PYG{l+s+sd}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}
\PYG{l+s+sd}{AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}
\PYG{l+s+sd}{LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,}
\PYG{l+s+sd}{OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE}
\PYG{l+s+sd}{SOFTWARE.}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{k+kn}{from} \PYG{n+nn}{heapq} \PYG{k+kn}{import} \PYG{n}{heapify}\PYG{p}{,} \PYG{n}{heappush}\PYG{p}{,} \PYG{n}{heappop}
\PYG{k+kn}{from} \PYG{n+nn}{pyvisgraph.visible\PYGZus{}vertices} \PYG{k+kn}{import} \PYG{n}{edge\PYGZus{}distance}
\PYG{k+kn}{from} \PYG{n+nn}{pyvisgraph.graph} \PYG{k+kn}{import} \PYG{n}{Point}
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n+nb}{dict}\PYG{o}{.}\PYG{n}{iteritems}
\PYG{k}{except} \PYG{n+ne}{AttributeError}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Python 3}
    \PYG{k}{def} \PYG{n+nf}{iteritems}\PYG{p}{(}\PYG{n}{d}\PYG{p}{):}
        \PYG{k}{return} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n}{d}\PYG{o}{.}\PYG{n}{items}\PYG{p}{())}
\PYG{k}{else}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Python 2}
    \PYG{k}{def} \PYG{n+nf}{iteritems}\PYG{p}{(}\PYG{n}{d}\PYG{p}{):}
        \PYG{k}{return} \PYG{n}{d}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{()}

\PYG{c+c1}{\PYGZsh{}Implementierung des Dijkstra\PYGZhy{}Algorithmus}
\PYG{c+c1}{\PYGZsh{}mit einem Priority\PYGZhy{}Dict (aehnlich Priority\PYGZhy{}Queue) umgesetzt}
\PYG{k}{def} \PYG{n+nf}{dijkstra}\PYG{p}{(}\PYG{n}{graph}\PYG{p}{,} \PYG{n}{origin}\PYG{p}{):}
    \PYG{n}{D} \PYG{o}{=} \PYG{p}{\PYGZob{}\PYGZcb{}} \PYG{c+c1}{\PYGZsh{}Distanz}
    \PYG{n}{P} \PYG{o}{=} \PYG{p}{\PYGZob{}\PYGZcb{}} \PYG{c+c1}{\PYGZsh{}Elternknoten}
    \PYG{n}{Q} \PYG{o}{=} \PYG{n}{priority\PYGZus{}dict}\PYG{p}{()}
    \PYG{n}{Q}\PYG{p}{[}\PYG{n}{origin}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Q}\PYG{p}{:}
        \PYG{n}{D}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Q}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}

        \PYG{n}{edges} \PYG{o}{=} \PYG{n}{graph}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{edges}\PYG{p}{:}
            \PYG{n}{w} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{get\PYGZus{}adjacent}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{n}{elength} \PYG{o}{=} \PYG{n}{D}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{o}{+} \PYG{n}{edge\PYGZus{}distance}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
            \PYG{k}{if} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n}{D}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{elength} \PYG{o}{\PYGZlt{}} \PYG{n}{D}\PYG{p}{[}\PYG{n}{w}\PYG{p}{]:}
                    \PYG{k}{raise} \PYG{n+ne}{ValueError}
            \PYG{k}{elif} \PYG{n}{w} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{Q} \PYG{o+ow}{or} \PYG{n}{elength} \PYG{o}{\PYGZlt{}} \PYG{n}{Q}\PYG{p}{[}\PYG{n}{w}\PYG{p}{]:}
                \PYG{n}{Q}\PYG{p}{[}\PYG{n}{w}\PYG{p}{]} \PYG{o}{=} \PYG{n}{elength}
                \PYG{n}{P}\PYG{p}{[}\PYG{n}{w}\PYG{p}{]} \PYG{o}{=} \PYG{n}{v}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{D}\PYG{p}{,} \PYG{n}{P}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Kuerzesten Weg vom Startpunkt zur y\PYGZhy{}Achse bestimmen}
\PYG{c+c1}{\PYGZsh{}Idee ist in Kapitel 1.5 beschrieben}
\PYG{k}{def} \PYG{n+nf}{shortest\PYGZus{}path}\PYG{p}{(}\PYG{n}{graph}\PYG{p}{,} \PYG{n}{origin}\PYG{p}{,} \PYG{n}{vlisa}\PYG{p}{,} \PYG{n}{vbus}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{}Dijkstra f체r alle Knoten ausf체hren}
    \PYG{n}{D}\PYG{p}{,} \PYG{n}{P} \PYG{o}{=} \PYG{n}{dijkstra}\PYG{p}{(}\PYG{n}{graph}\PYG{p}{,} \PYG{n}{origin}\PYG{p}{)}
    \PYG{n}{mintime} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{inf}
    \PYG{n}{minpoint} \PYG{o}{=} \PYG{n}{Point}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{min\PYGZus{}bus\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mf}{0.0}
    \PYG{c+c1}{\PYGZsh{}Besten Companion\PYGZhy{}Punkt bestimmen...}
    \PYG{k}{for} \PYG{n}{point} \PYG{o+ow}{in} \PYG{n}{graph}\PYG{o}{.}\PYG{n}{get\PYGZus{}points}\PYG{p}{():}
        \PYG{k}{if} \PYG{n}{point}\PYG{o}{.}\PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{bus\PYGZus{}time} \PYG{o}{=} \PYG{n}{point}\PYG{o}{.}\PYG{n}{y} \PYG{o}{/} \PYG{n}{vbus}
            \PYG{n}{lisa\PYGZus{}time} \PYG{o}{=} \PYG{n}{D}\PYG{p}{[}\PYG{n}{point}\PYG{p}{]} \PYG{o}{/} \PYG{n}{vlisa}
            \PYG{c+c1}{\PYGZsh{}... mithilfe der sp채testen Startzeit}
            \PYG{c+c1}{\PYGZsh{}Zeitangabe: negativ vor 7.30, positiv danach}
            \PYG{n}{total\PYGZus{}time} \PYG{o}{=} \PYG{n}{bus\PYGZus{}time} \PYG{o}{\PYGZhy{}} \PYG{n}{lisa\PYGZus{}time}
            \PYG{k}{if} \PYG{n}{total\PYGZus{}time} \PYG{o}{\PYGZgt{}} \PYG{n}{mintime}\PYG{p}{:}
                \PYG{n}{mintime} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{total\PYGZus{}time}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
                \PYG{n}{minpoint} \PYG{o}{=} \PYG{n}{point}
                \PYG{n}{min\PYGZus{}bus\PYGZus{}time} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{bus\PYGZus{}time}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}Pfad zum Punkt finden und zur체ckgeben}
    \PYG{n}{path} \PYG{o}{=} \PYG{p}{[]}
    \PYG{n}{destination} \PYG{o}{=} \PYG{n}{minpoint}
    \PYG{k}{while} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{destination}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{destination} \PYG{o}{==} \PYG{n}{origin}\PYG{p}{:} \PYG{k}{break}
        \PYG{n}{destination} \PYG{o}{=} \PYG{n}{P}\PYG{p}{[}\PYG{n}{destination}\PYG{p}{]}
    \PYG{n}{path}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{()}
    \PYG{k}{return} \PYG{n}{path}\PYG{p}{,}\PYG{n}{mintime}\PYG{p}{,}\PYG{n}{min\PYGZus{}bus\PYGZus{}time}\PYG{p}{,} \PYG{n}{minpoint}\PYG{p}{,}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{D}\PYG{p}{[}\PYG{n}{minpoint}\PYG{p}{],}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Priority\PYGZhy{}Dict als Implementierung einer Priority\PYGZhy{}Queue}
\PYG{k}{class} \PYG{n+nc}{priority\PYGZus{}dict}\PYG{p}{(}\PYG{n+nb}{dict}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Dictionary that can be used as a priority queue.}

\PYG{l+s+sd}{    Keys of the dictionary are items to be put into the queue, and values}
\PYG{l+s+sd}{    are their respective priorities. All dictionary methods work as expected.}
\PYG{l+s+sd}{    The advantage over a standard heapq\PYGZhy{}based priority queue is that priorities}
\PYG{l+s+sd}{    of items can be efficiently updated (amortized O(1)) using code as}
\PYG{l+s+sd}{    \PYGZsq{}thedict[item] = new\PYGZus{}priority.\PYGZsq{}}

\PYG{l+s+sd}{    Note that this is a modified version of}
\PYG{l+s+sd}{    https://gist.github.com/matteodellamico/4451520 where sorted\PYGZus{}iter() has}
\PYG{l+s+sd}{    been replaced with the destructive sorted iterator \PYGZus{}\PYGZus{}iter\PYGZus{}\PYGZus{} from}
\PYG{l+s+sd}{    https://gist.github.com/anonymous/4435950}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{**}\PYG{n}{kwargs}\PYG{p}{):}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{priority\PYGZus{}dict}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{**}\PYG{n}{kwargs}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}rebuild\PYGZus{}heap}\PYG{p}{()}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}rebuild\PYGZus{}heap}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}heap} \PYG{o}{=} \PYG{p}{[(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)} \PYG{k}{for} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{iteritems}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)]}
        \PYG{n}{heapify}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}heap}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{smallest}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
        \PYG{n}{heap} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}heap}
        \PYG{n}{v}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{heap}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{k}{while} \PYG{n}{k} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n+nb+bp}{self} \PYG{o+ow}{or} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{v}\PYG{p}{:}
            \PYG{n}{heappop}\PYG{p}{(}\PYG{n}{heap}\PYG{p}{)}
            \PYG{n}{v}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{heap}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{k}

    \PYG{k}{def} \PYG{n+nf}{pop\PYGZus{}smallest}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
        \PYG{n}{heap} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}heap}
        \PYG{n}{v}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{heappop}\PYG{p}{(}\PYG{n}{heap}\PYG{p}{)}
        \PYG{k}{while} \PYG{n}{k} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n+nb+bp}{self} \PYG{o+ow}{or} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{v}\PYG{p}{:}
            \PYG{n}{v}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{heappop}\PYG{p}{(}\PYG{n}{heap}\PYG{p}{)}
        \PYG{k}{del} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{k}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}setitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{key}\PYG{p}{,} \PYG{n}{val}\PYG{p}{):}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{priority\PYGZus{}dict}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}setitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}

        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}heap}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
            \PYG{n}{heappush}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}heap}\PYG{p}{,} \PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{key}\PYG{p}{))}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}rebuild\PYGZus{}heap}\PYG{p}{()}

    \PYG{k}{def} \PYG{n+nf}{setdefault}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{key}\PYG{p}{,} \PYG{n}{val}\PYG{p}{):}
        \PYG{k}{if} \PYG{n}{key} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]} \PYG{o}{=} \PYG{n}{val}
            \PYG{k}{return} \PYG{n}{val}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}

    \PYG{k}{def} \PYG{n+nf}{update}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{**}\PYG{n}{kwargs}\PYG{p}{):}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{priority\PYGZus{}dict}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{**}\PYG{n}{kwargs}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}rebuild\PYGZus{}heap}\PYG{p}{()}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}iter\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
        \PYG{k}{def} \PYG{n+nf}{iterfn}\PYG{p}{():}
            \PYG{k}{while} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
                \PYG{n}{x} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{smallest}\PYG{p}{()}
                \PYG{k}{yield} \PYG{n}{x}
                \PYG{k}{del} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{iterfn}\PYG{p}{()}
\end{Verbatim}
